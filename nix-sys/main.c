#include <cdb.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/sendfile.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

#include "chattr.h"

struct copy_a {
	const char *source;
	const char *tmp;
	const char *destination;
	const char *backup;
	mode_t mode;
	uid_t owner;
	gid_t group;
};

struct symlink_a {
	const char *source;
	const char *tmp;
	const char *destination;
	const char *backup;
};

struct mkdir_a {
	const char *destination;
	mode_t mode;
	uid_t owner;
	gid_t group;
};

#include "config.h" // generated by builder.py

#define ARRAY_SIZE(x) ((sizeof(x))/ (sizeof(x[0])))
#define write2(x) (void) write(2, x"", sizeof(x) - 1)

static inline void write2_s(const char *s)
{
	write(2, s, strlen(s));
}

/*
 * Create directory, maybe we speicified permissions and ownership.
 *
 * Only empty directories can be created atomically with standard POSIX
 * trick -- create, set owner/permission, rename. If directory already
 * exists, we have to modify its attributes inplace, so to keep things
 * simple directory is modified inplace in all cases.
 */
static int prepare_mkdir(const struct mkdir_a *ptr)
{
	struct stat sb;
	const char *path;
	int err;
	int need_chown, need_chmod;

	path = ptr->destination;
	err = lstat(path, &sb);

	if (!err) { /* something exists on this path */
		if ((sb.st_mode & S_IFMT) != S_IFDIR) {
			write2("fail (exists, but not a directory)\n");
			return 1;
		}
		write2("ok (exists)\n");
		need_chmod = (sb.st_mode & 07777) != ptr->mode;
		need_chown = (sb.st_uid != ptr->owner) ||
		             (sb.st_gid != ptr->group);
	} else {
		err = mkdir(path, ptr->mode);
		if (err) {
			write2("fail (can't create)\n");
			return 1;
		}
		write2("ok (created)\n");
		need_chmod = 0;
		need_chown = (ptr->owner != 0) || (ptr->group != 0);
	}

	if (need_chmod) {
		write2("  fixing permissions... ");
		err = chmod(path, ptr->mode);
		if (err) {
			write2("fail\n");
			return 1;
		}
		write2("ok\n");
	}

	if (need_chown) {
		write2("  fixing ownership... ");
		err = chown(path, ptr->owner, ptr->group);
		if (err) {
			write2("fail\n");
			return 1;
		}
		write2("ok\n");
	}

	return 0;
}

static int prepare_copy(const struct copy_a *ptr)
{
	int err;
	int in, out;
	off_t off = 0;
	ssize_t bytes;

	in = open(ptr->source, O_RDONLY);
	if (in == -1) {
		write2("fail (can't open source file)\n");
		write2_s(ptr->source);
		write2("\n");
		return 1;
	}

	out = open(ptr->tmp, O_EXCL|O_WRONLY|O_CREAT|O_NOFOLLOW, 0);
	if (out == -1) {
		write2("fail (can't open temporary file)\n");
		write2_s(ptr->tmp);
		write2("\n");
		close(in);
		return 1;
	}

	/* Make it portable. sendfile is Linux-specific. */
	while ((bytes = sendfile(out, in, &off, 4096000)) > 0)
		;
	if (bytes == -1) {
		write2("fail (io error)\n");
		close(in);
		close(out);
		return 1;
	}
	close(in);
	close(out);

	err = chmod(ptr->tmp, ptr->mode);
	if (err) {
		write2("fail (can't set permissions)");
		return 1;
	}

	if (ptr->owner || ptr->group) {
		err = chown(ptr->tmp, ptr->owner, ptr->group);
		if (err) {
			write2("fail (can't set owner/group)");
			return 1;
		}
	}

	write2("ok\n");
	return 0;
}

static int prepare_symlink(const struct symlink_a *ptr)
{
	int err = symlink(ptr->source, ptr->tmp);
	if (err)
		write2("fail\n");
	else
		write2("ok\n");
	return err;
}

int xopen_cdb(struct cdb *cdbp, const char *filename, int missing_ok)
{
	int fd;
	int err;

	cdbp->cdb_fd = -1;
	fd = open(filename, O_RDONLY);
	if (fd < 0) {
		if (missing_ok && errno == ENOENT) {
			write2("skip (missing)\n");
			return 0;
		}
		write2("fail\n");
		return 1;
	}

	err = cdb_init(cdbp, fd);
	if (err) {
		write2("fail (corrupted)\n");
		return 1;
	}
	write2("ok\n");
	return 0;
}

/*
 * If target already exists and is not managed by previous generation,
 * create backup of it before overwriting target.
 */
int make_backup(struct cdb *cdbp, const char *target, const char *backup)
{
	int err;

	write2("checking if ");
	write2_s(target);
	write2(" needs backup... ");

	/* In old generation, nothing to do. */
	if (cdb_find(cdbp, target, strlen(target) + 1) == 1) {
		write2("no\n");
		return 0;
	}

	err = access(target, F_OK);
	if (err) {
		write2("no\n");
		return 0;
	}
	write2("yes\n");

	err = access(backup, F_OK);
	if (!err) {
		write2("error: backup file ");
		write2_s(backup);
		write2(" already exists\n");
		return 1;
	}

	write2("creating backup file for ");
	write2_s(target);
	write2("... ");

	err = link(target, backup);
	if (err) {
		write2("fail\n");
		return 1;
	}
	write2("ok\n");
	return 0;
}

/*
 * Value, associated with {key} is a list of parent directories. For file
 * "/foo/bar/baz" parents will be layout in following way:
 * /foo/bar<NUL>/foo<NUL><NUL>
 *
 * This layout makes reading code (here, in C) very simple at expense of
 * added complexity in nix-sys-generate. Difference is that this code is run
 * as root on live system, while nix-sys-generate is run in Nix sandbox.
 */
void purge_stale1(const char *key, const char *parents, size_t len)
{
	int err;
	const char *begin;

	write2("purging stale ");
	write2_s(key);
	write2("... ");
	(void) immutable_off(key);
	err = remove(key);
	if (err) {
		write2("fail (contining anyway)\n");
		return;
	}

	write2("ok\n");
	begin = parents;
	while (*begin) {
		void *end = memchr(begin, 0, len - (begin - parents));
		if (!end) {
			write2("\tcorrupted value in database");
			return;
		}

		err = rmdir(begin);
		/*
		 * If we failed to purge parent directory, then we
		 * obliviously will fail to purge it's parent, so there
		 * is no use wasting syscalls -- break early.
		 */
		if (err)
			break;

		write2("purging stale directory ");
		write2_s(begin);
		write2("... ok\n");
		begin = end + 1;
	}
}

int main(int argc, char **argv)
{
	int err, err2 = 0, status;
	int i, j;
	struct cdb ix_new, ix_old;
	unsigned int iter;
	const char *const exec_argv[] = { exec, NULL };
	/* exec script is deliberately run in empty environment. */
	const char *const exec_envp[] = { NULL };
	

	write2("opening index of new generation... ");
	err = xopen_cdb(&ix_new, newcdb_path, 0); /* missing_ok == false */
	if (err)
		return err;

	write2("opening index of previous generation... ");
	err = xopen_cdb(&ix_old, oldcdb_path, 1);
	if (err)
		return err;

	umask(0); /* always succeeds */
	for (i = 0; i != ARRAY_SIZE(to_mkdir); ++i) {
		write2("preparing directory "); 
		write2_s(to_mkdir[i].destination);
		write2("... ");

		err = prepare_mkdir(to_mkdir + i);
		if (err) return 1;
	}

	for (i = 0; i != ARRAY_SIZE(to_copy); ++i) {
		write2("preparing copy for ");
		write2_s(to_copy[i].destination);
		write2("... ");
		err = prepare_copy(to_copy + i);
		if (!err) {
			err2 = make_backup(&ix_old, to_copy[i].destination
			                          , to_copy[i].backup);
		}
		if (err || err2) { /* clean-up */
			for (j = 0; j <= i; ++j) {
				unlink(to_copy[j].backup);
				unlink(to_copy[j].tmp);
			}
			return 1;
		}
	};

	for (i = 0; i != ARRAY_SIZE(to_symlink); ++i) {
		write2("preparing symlink for ");
		write2_s(to_symlink[i].destination);
		write2("... ");
		err = prepare_symlink(to_symlink + i);
		if (!err) {
			err2 = make_backup(&ix_old, to_symlink[i].destination
			                          , to_symlink[i].backup);
		}

		if (err || err2) {
			for (j = 0; j <= i; ++j) {
				unlink(to_symlink[j].backup);
				unlink(to_symlink[j].tmp);
			}
			for (j = 0; j != ARRAY_SIZE(to_copy); ++j) {
				unlink(to_copy[j].backup);
				unlink(to_copy[j].tmp);
			}
			return 1;
		}
	}

	for (i = 0; i != ARRAY_SIZE(to_copy); ++i) {
		const struct copy_a *obj = &to_copy[i];

		write2("renaming copy into ");
		write2_s(obj->destination);
		write2("... ");

		/* Make file immutable (chattr +i) so it can't be
		 * modified by mistake. Linux-only.
		 *
		 * TODO: Check errors properly.
		 */
		(void) immutable_off(obj->destination);
		err = rename(obj->tmp, obj->destination);
		(void) immutable_on(obj->destination);

		if (err) {
			write2("fail\n");
			return 1;
		}
		write2("ok\n");
	}

	for (i = 0; i != ARRAY_SIZE(to_symlink); ++i) {
		const struct symlink_a *obj = &to_symlink[i];

		write2("renaming symlink into ");
		write2_s(obj->destination);
		write2("... ");
		err = rename(obj->tmp, obj->destination);
		if (err) {
			write2("fail\n");
			return 1;
		}
		write2("ok\n");
	}


	for (i = 0; i != ARRAY_SIZE(to_unlink); ++i) {
		const char *target = to_unlink[i];
		write2("unlinking ");
		write2_s(target);
		write2("... ");

		err = unlink(target);
		if (err && (errno == ENOENT)) {
			write2("skip (does not exist)\n");
		} else if (!err) {
			write2("ok (unlinked)\n");
		} else {
			write2("fail (contining anyway)\n");
			status = 1;
		}
	}

	if (ix_old.cdb_fd != -1) {
		cdb_seqinit(&iter, &ix_old);

		while (cdb_seqnext(&iter, &ix_old) > 0) {
			const char *key = cdb_getkey(&ix_old);
			unsigned int keylen = cdb_keylen(&ix_old);
			if (cdb_find(&ix_new, key, keylen) == 0) {
				const char *parents = cdb_getdata(&ix_old);
				unsigned int datalen = cdb_datalen(&ix_old);
				purge_stale1(key, parents, datalen);
			}
		}
	}
	cdb_free(&ix_new);
	close(ix_new.cdb_fd);

	if (ix_old.cdb_fd != -1) {
		cdb_free(&ix_old);
		close(ix_old.cdb_fd);
	}

	if (status != 0) {
		return status;
	}

	if (*exec) {
		return execve(exec, (void*)exec_argv, (void*)exec_envp);
	}
}
