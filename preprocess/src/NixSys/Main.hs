{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralisedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}

module NixSys.Main where

import Control.Applicative
import Control.Monad
import Data.Aeson
import Data.Aeson.TH
import Data.Aeson.Types
import Data.Coerce (coerce)
import qualified Data.HashMap.Strict as HashMap
import Data.List (inits)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Lazy.IO as TIO
import qualified Data.Vector as Vector
import Data.Word (Word16, Word32)
import NixSys.CmdOptions
import Numeric (readOct)
import System.Exit (exitFailure)
import Text.Mustache (renderMustache)
import Text.Mustache.Compile.TH (compileMustacheFile)

-- Absolute file path. We are not performing any operation on it except
-- validating that it is actually absolute (starts with /).
newtype Location = Location Text deriving (Eq, Ord, Show)

$(deriveToJSON defaultOptions ''Location)

parseLocation :: Text -> Parser Location
parseLocation t = do
  unless (T.isPrefixOf "/" t) $
    fail $ "Location `" <> T.unpack t <> "' is not absolute"
  when (T.isInfixOf "/./" t || T.isInfixOf "/../" t) $
    fail $ "Location `" <> T.unpack t <> "' contains redundant path segments"
  pure $ Location t

instance FromJSON Location where
  parseJSON = withText "Location" parseLocation

instance FromJSONKey Location where
  fromJSONKey = FromJSONKeyTextParser parseLocation

-- Mode of the file. We are not performing any operations on it except
-- substituting it into template, so we do not use more type-safe
-- representation.
newtype Mode = Mode Word16 deriving (Show)

$(deriveToJSON defaultOptions ''Mode)

instance FromJSON Mode where
  parseJSON e = parseText e <|> parseInt e
    where
      parseWord w = do
        unless (w < 07777) $
          fail "Mode value can't be greater than 07777"
        pure $ Mode w
      parseInt e = parseJSON e >>= parseWord
      parseText e = do
        s <- parseJSON e
        case readOct s of
          [(w, "")] -> parseWord w
          _ -> fail "Mode string value does not represent octal value"

-- Specification that file at specified location must be regular file with
-- specified mode, ownership and content copied from another file (presumably
-- in Nix store)
data SpecCopy = SpecCopy
  { path :: Location,
    mode :: Mode,
    owner :: Word32,
    group :: Word32
  }
  deriving (Show)

$(deriveToJSON defaultOptions ''SpecCopy)

data SpecMkdir = SpecMkdir
  { mode :: Mode,
    owner :: Word32,
    group :: Word32
  }
  deriving (Show)

$(deriveToJSON defaultOptions ''SpecMkdir)

newtype SpecSymlink = SpecSymlink {path :: Location}
  deriving (Show)

instance FromJSON SpecSymlink where
  parseJSON = withObject "SpecSymlink" $ \o ->
    SpecSymlink <$> ((o .: "path") >>= parseLocation)

$(deriveToJSON defaultOptions ''SpecSymlink)

data Spec = Spec
  { copy :: Map Location SpecCopy,
    mkdir :: Map Location SpecMkdir,
    symlink :: Map Location SpecSymlink,
    exec :: Maybe Location
  }
  deriving (Show)

instance FromJSON SpecMkdir where
  parseJSON = withObject "SpecMkdir" $ \o ->
    SpecMkdir <$> o .: "mode"
      <*> fmap (fromMaybe 0) (o .:? "owner")
      <*> fmap (fromMaybe 0) (o .:? "group")

instance FromJSON SpecCopy where
  parseJSON = withObject "SpecMkdir" $ \o ->
    SpecCopy <$> o .: "path"
      <*> o .: "mode"
      <*> fmap (fromMaybe 0) (o .:? "owner")
      <*> fmap (fromMaybe 0) (o .:? "group")

-- Instance generated by TH makes map fields mandatory. It is possible to make
-- it optional by declaring it (Maybe Map) instead of just Map, but it would
-- require extra processing.
--
-- I prefer to contain as much complexity as possible in the parser. This way I
-- automatically get decent error messages.
instance FromJSON Spec where
  parseJSON = withObject "Spec" $ \o ->
    Spec
      <$> fmap (fromMaybe Map.empty) (o .:? "copy")
      <*> fmap (fromMaybe Map.empty) (o .:? "mkdir")
      <*> fmap (fromMaybe Map.empty) (o .:? "symlink")
      <*> o .:? "exec"

-- Return sorted list of parent directories of spec targets, so nix-sys
-- do not need to do string manipulation in C.
parents :: Spec -> [Text]
parents s =
  let locations =
        coerce $
          Map.keys (copy s)
            ++ Map.keys (mkdir s)
            ++ Map.keys (symlink s)
      parents1 :: Text -> [Text]
      parents1 = map (T.intercalate "/") . inits . T.splitOn "/"

      sortAsc :: Ord a => [a] -> [a]
      sortAsc = Set.toList . Set.fromList
   in sortAsc . filter (/= "") . join . map parents1 $ locations

-- Mustache does not support iterating over dictionary keys, only over
-- list elements, but 'Spec' datatype uses dictionary instead of list to
-- make some incoherent manifests unrepresentable.
--
-- So here we convert it dictionary with variable keys into the list.
-- This function uses partial functions to avoid a lot of boilerplate,
-- but is total by itself.
specToContext :: Spec -> Text -> Value
specToContext s hash =
  object
    [ ("copy", fromMap (copy s)),
      ("mkdir", fromMap (mkdir s)),
      ("symlink", fromMap (symlink s)),
      ("exec", maybe Null locToString (exec s)),
      ("parents", Array . Vector.fromList . map String . parents $ s)
    ]
  where
    locToString :: Location -> Value
    locToString (Location s) = String s

    fromMap :: (ToJSON a) => Map Location a -> Value
    fromMap = Array . Vector.fromList . map f . Map.toList

    f :: ToJSON a => (Location, a) -> Value
    f (Location target, a) =
      let Object m = toJSON a -- partial
       in Object
            . HashMap.insert "target" (String target)
            . HashMap.insert "hash" (String hash)
            $ m

main = do
  CmdOptions {..} <- ioCmdOptions
  spec <-
    eitherDecodeFileStrict manifestFile >>= \case
      Left err -> putStrLn err >> exitFailure
      Right a -> pure a
  let template = $(compileMustacheFile "./data/config.h.mustache")
  TIO.writeFile outputConfig $
    renderMustache template (specToContext spec "foo")
