{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module NixSys.Parser where

import Control.Applicative ((<|>))
import Control.Monad (unless, when)
import Data.Aeson (withObject, withText, (.:), (.:?))
import Data.Aeson.TH (Options (..), defaultOptions, deriveToJSON)
import Data.Aeson.Types
  ( FromJSON (..),
    FromJSONKey (..),
    FromJSONKeyFunction (..),
    Parser,
    Value,
  )
import Data.Functor (($>))
import qualified Data.HashMap.Strict as H
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Word (Word16, Word32)
import Numeric (readOct)

-- Absolute file path. We are not performing any operation on it except
-- validating that it is actually absolute (starts with /).
newtype Location = Location Text deriving (Eq, Ord, Show)

$(deriveToJSON defaultOptions ''Location)

parseLocation :: Text -> Parser Location
parseLocation t = do
  unless (T.isPrefixOf "/" t) $
    fail $ "Location `" <> T.unpack t <> "' is not absolute"
  when (T.isInfixOf "/./" t || T.isInfixOf "/../" t) $
    fail $ "Location `" <> T.unpack t <> "' contains redundant path segments"
  pure $ Location t

instance FromJSON Location where
  parseJSON = withText "Location" parseLocation

instance FromJSONKey Location where
  fromJSONKey = FromJSONKeyTextParser parseLocation

-- Mode of the file. We are not performing any operations on it except
-- substituting it into template, so we do not use more type-safe
-- representation.
newtype Mode = Mode Word16 deriving (Show)

$(deriveToJSON defaultOptions ''Mode)

instance FromJSON Mode where
  parseJSON e = parseText e <|> parseInt e
    where
      parseWord w = do
        unless (w < 07777) $
          fail "Mode value can't be greater than 07777"
        pure $ Mode w
      parseInt v = parseJSON v >>= parseWord
      parseText v = do
        s <- parseJSON v
        case readOct s of
          [(w, "")] -> parseWord w
          _ -> fail "Mode string value does not represent octal value"

-- Specification that file at specified location must be regular file with
-- specified mode, ownership and content copied from another file (presumably
-- in Nix store)
data SpecCopy = SpecCopy
  { path :: Location,
    mode :: Mode,
    owner :: Word32,
    group :: Word32
  }
  deriving (Show)

$(deriveToJSON (defaultOptions {rejectUnknownFields = True}) ''SpecCopy)

data SpecMkdir = SpecMkdir
  { mode :: Mode,
    owner :: Word32,
    group :: Word32
  }
  deriving (Show)

$(deriveToJSON (defaultOptions {rejectUnknownFields = True}) ''SpecMkdir)

newtype SpecSymlink = SpecSymlink {path :: Location}
  deriving (Show)

checkKnownFields :: H.HashMap Text Value -> [Text] -> Parser ()
checkKnownFields m kf = do
  let known = H.fromList $ map (\x -> (x, ())) kf
      actual = m $> ()
      diff = map fst . H.toList $ H.difference actual known
  unless (null diff) $ do
    fail $ "unknownFields: " ++ show diff

instance FromJSON SpecSymlink where
  parseJSON = withObject "SpecSymlink" $ \o -> do
    checkKnownFields o ["path"]
    SpecSymlink <$> ((o .: "path") >>= parseLocation)

$(deriveToJSON defaultOptions ''SpecSymlink)

data Spec = Spec
  { copy :: Map Location SpecCopy,
    mkdir :: Map Location SpecMkdir,
    symlink :: Map Location SpecSymlink,
    exec :: Maybe Location
  }
  deriving (Show)

instance FromJSON SpecMkdir where
  parseJSON = withObject "SpecMkdir" $ \o -> do
    checkKnownFields o ["mode", "owner", "group"]
    SpecMkdir <$> o .: "mode"
      <*> fmap (fromMaybe 0) (o .:? "owner")
      <*> fmap (fromMaybe 0) (o .:? "group")

instance FromJSON SpecCopy where
  parseJSON = withObject "SpecMkdir" $ \o -> do
    checkKnownFields o ["path", "mode", "owner", "group"]
    SpecCopy <$> o .: "path"
      <*> o .: "mode"
      <*> fmap (fromMaybe 0) (o .:? "owner")
      <*> fmap (fromMaybe 0) (o .:? "group")

-- Instance generated by TH makes map fields mandatory. It is possible to make
-- it optional by declaring it (Maybe Map) instead of just Map, but it would
-- require extra processing.
--
-- I prefer to contain as much complexity as possible in the parser. This way I
-- automatically get decent error messages.
instance FromJSON Spec where
  parseJSON = withObject "Spec" $ \o -> do
    checkKnownFields o ["copy", "mkdir", "symlink", "exec"]
    Spec
      <$> fmap (fromMaybe Map.empty) (o .:? "copy")
      <*> fmap (fromMaybe Map.empty) (o .:? "mkdir")
      <*> fmap (fromMaybe Map.empty) (o .:? "symlink")
      <*> o .:? "exec"
